use crate::domain::outbox_event::{CustomerEvent, SubscriptionEvent};
use crate::errors::{StoreError, StoreErrorReport};
use crate::json_value_serde;
use common_domain::ids::{CustomerId, InvoiceId, SubscriptionId, TenantId};
use common_domain::pgmq::{Headers, Message, MessageId, ReadCt};
use diesel_models::pgmq::{PgmqMessageRow, PgmqMessageRowNew};
use o2o::o2o;
use serde::{Deserialize, Serialize};
use strum::Display;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Display)]
pub enum PgmqQueue {
    OutboxEvent,
    InvoicePdfRequest,
    WebhookOut,
    HubspotSync,
    PennylaneSync,
}

impl PgmqQueue {
    pub fn as_str(&self) -> &'static str {
        match self {
            PgmqQueue::OutboxEvent => "outbox_event",
            PgmqQueue::InvoicePdfRequest => "invoice_pdf_request",
            PgmqQueue::WebhookOut => "webhook_out",
            PgmqQueue::HubspotSync => "hubspot_sync",
            PgmqQueue::PennylaneSync => "pennylane_sync",
        }
    }
}

#[derive(Debug, Clone, o2o)]
#[from_owned(PgmqMessageRow)]
pub struct PgmqMessage {
    pub msg_id: MessageId,
    pub message: Option<Message>,
    pub headers: Option<Headers>,
    pub read_ct: ReadCt,
}

#[derive(Debug, Clone, o2o)]
#[owned_into(PgmqMessageRowNew)]
pub struct PgmqMessageNew {
    pub message: Option<Message>,
    pub headers: Option<Headers>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvoicePdfRequestEvent {
    pub invoice_id: InvoiceId,
}

impl InvoicePdfRequestEvent {
    pub fn new(invoice_id: InvoiceId) -> Self {
        Self { invoice_id }
    }
}

json_value_serde!(InvoicePdfRequestEvent);

impl TryInto<PgmqMessageNew> for InvoicePdfRequestEvent {
    type Error = StoreErrorReport;

    fn try_into(self) -> Result<PgmqMessageNew, Self::Error> {
        let message = Some(Message(self.try_into()?));

        Ok(PgmqMessageNew {
            message,
            headers: None,
        })
    }
}

impl TryInto<InvoicePdfRequestEvent> for &PgmqMessage {
    type Error = StoreErrorReport;

    fn try_into(self) -> Result<InvoicePdfRequestEvent, Self::Error> {
        let payload = &self
            .message
            .as_ref()
            .ok_or(StoreError::ValueNotFound("Pgmq message".to_string()))?
            .0;

        payload.try_into()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HubspotSyncRequestEvent {
    /// sync customer and everything related to it
    CustomerDomain(Box<HubspotSyncCustomerDomain>),
    /// sync subscription
    Subscription(Box<HubspotSyncSubscription>),
    /// sync event generated by an outbox event
    CustomerOutbox(Box<CustomerEvent>),
    /// sync event generated by an outbox event
    SubscriptionOutbox(Box<SubscriptionEvent>),
    /// sync custom properties
    CustomProperties(TenantId),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HubspotSyncCustomerDomain {
    pub id: CustomerId,
    pub tenant_id: TenantId,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HubspotSyncSubscription {
    pub id: SubscriptionId,
    pub tenant_id: TenantId,
}

impl HubspotSyncRequestEvent {
    pub fn tenant_id(&self) -> TenantId {
        match self {
            HubspotSyncRequestEvent::CustomerDomain(data) => data.tenant_id,
            HubspotSyncRequestEvent::Subscription(data) => data.tenant_id,
            HubspotSyncRequestEvent::CustomerOutbox(event) => event.tenant_id,
            HubspotSyncRequestEvent::SubscriptionOutbox(event) => event.tenant_id,
            HubspotSyncRequestEvent::CustomProperties(tenant_id) => *tenant_id,
        }
    }
}

json_value_serde!(HubspotSyncRequestEvent);

impl TryInto<PgmqMessageNew> for HubspotSyncRequestEvent {
    type Error = StoreErrorReport;

    fn try_into(self) -> Result<PgmqMessageNew, Self::Error> {
        let message = Some(Message(self.try_into()?));

        Ok(PgmqMessageNew {
            message,
            headers: None,
        })
    }
}

impl TryInto<HubspotSyncRequestEvent> for &PgmqMessage {
    type Error = StoreErrorReport;

    fn try_into(self) -> Result<HubspotSyncRequestEvent, Self::Error> {
        let payload = &self
            .message
            .as_ref()
            .ok_or(StoreError::ValueNotFound("Pgmq message".to_string()))?
            .0;

        payload.try_into()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PennylaneSyncRequestEvent {
    /// sync customer
    Customer(Box<PennylaneSyncCustomer>),
    /// sync invoice
    Invoice(Box<PennylaneSyncInvoice>),
    /// sync event generated by an outbox event
    CustomerOutbox(Box<CustomerEvent>),
}

impl PennylaneSyncRequestEvent {
    pub fn tenant_id(&self) -> TenantId {
        match self {
            PennylaneSyncRequestEvent::CustomerOutbox(event) => event.tenant_id,
            PennylaneSyncRequestEvent::Customer(event) => event.tenant_id,
            PennylaneSyncRequestEvent::Invoice(event) => event.tenant_id,
        }
    }
}

json_value_serde!(PennylaneSyncRequestEvent);

impl TryInto<PgmqMessageNew> for PennylaneSyncRequestEvent {
    type Error = StoreErrorReport;

    fn try_into(self) -> Result<PgmqMessageNew, Self::Error> {
        let message = Some(Message(self.try_into()?));

        Ok(PgmqMessageNew {
            message,
            headers: None,
        })
    }
}

impl TryInto<PennylaneSyncRequestEvent> for &PgmqMessage {
    type Error = StoreErrorReport;

    fn try_into(self) -> Result<PennylaneSyncRequestEvent, Self::Error> {
        let payload = &self
            .message
            .as_ref()
            .ok_or(StoreError::ValueNotFound("Pgmq message".to_string()))?
            .0;

        payload.try_into()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PennylaneSyncCustomer {
    pub id: CustomerId,
    pub tenant_id: TenantId,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PennylaneSyncInvoice {
    pub id: InvoiceId,
    pub tenant_id: TenantId,
}
