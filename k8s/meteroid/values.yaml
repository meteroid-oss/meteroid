version: tip

commonSettings: &commonSettings
  replicaCount: 1
  autoscaling:
    enabled: false
  image:
    pullPolicy: Always
  podAnnotations: {}
  podLabels: {}
  tolerations: []
  nodeSelector: {}
  affinity: {}
  extraEnv: {}
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
  terminationGracePeriodSeconds: 30

meteroid:
  revisionHistoryLimit: 10
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL

serviceAccount:
  create: true
  name: null
  imagePullSecrets: []
  annotations: {}
  automountServiceAccountToken: true

global:
  publicAppUrl: "http://meteroid.local"
  publicApiUrl: "http://api.meteroid.local"
  publicRestApiUrl: "http://api.meteroid.local/api"

  telemetry:
    tracingEnabled: false
    metricsEnabled: false
    otelEndpoint: ""

  smtp:
    # host: ""
    # from: "Hey <hey@example.com>"
    # tls: true

  objectStore:
    uri: ""
    # s3ndpoint: ""

  secrets:
    # if using an external secret use this
    existingSecretName: ""

    # # else provide below
    # databaseUrl: ""  # only if postgresql.enabled is false
    # jwtPrivateKey: ""
    # internalApiSecret: ""
    # secretsCryptkey: ""
    # svixJwtToken: ""
    # oauthGoogle:
    #   clientId: ""
    #   clientSecret: ""
    # objectStore:
    #   accessKeyId: ""
    #   secretAccessKey: ""
    # smtp:
    #   username: ""
    #   password: ""

  # External services configuration (used when dependencies are disabled)
  kafka:
    bootstrapServers: ""
    # securityProtocol: ""
    # saslMechanism: ""
    # saslUsername: ""

  clickhouse:
    address: ""
    httpAddress: ""
    tcpAddress: ""
    database: "meteroid"
    username: "meteroid"
    clusterName: "meteroid"

ingress:
  # Enable routing configuration (generates either Ingress or IngressRoute based on useIngressRoute)
  enabled: true
  # Use Traefik IngressRoute CRD (true) or standard Kubernetes Ingress (false)
  # Note: IngressRoute is required for per-host rate limiting via middlewares
  useIngressRoute: false
  className: nginx
  annotations:
  # Traefik rate limiting configuration (requires useIngressRoute: true)
  # Middlewares are automatically added to routes based on rateLimit config
  hosts:
    - host: meteroid.local
      # Per-host per-IP rate limit (via X-Forwarded-For header)
      # Middlewares are auto-injected - no need to specify manually
      # rateLimit:
      #   perIp:
      #     average: 100
      #     burst: 50
      paths:
        - path: /
          pathType: Prefix
          service: web
          port: 80
    - host: api.meteroid.local
      paths:
        - path: /
          pathType: Prefix
          service: api
          port: 50061
        - path: /api
          pathType: Prefix
          service: api
          port: 8080

api:
  <<: *commonSettings
  image:
    repository: ghcr.io/meteroid-oss/meteroid-api
    tag: tip
  service:
    type: ClusterIP
    ports:
      http: 8080
      grpc: 50061
  config:
    enableMultiOrganization: false
    svixServerUrl: ""
    kafka: {}
  httpStartupProbe:
    initialDelaySeconds: 5
    periodSeconds: 5
    failureThreshold: 10
    path: /health
  httpLivenessProbe:
    periodSeconds: 20
  httpReadinessProbe:
    periodSeconds: 10
    path: /health

# Web Configuration
web:
  <<: *commonSettings
  image:
    repository: ghcr.io/meteroid-oss/meteroid-web
    tag: tip
  service:
    type: ClusterIP
    ports:
      - port: 80
        targetPort: http
        protocol: TCP
        name: http

# Metering Configuration
metering:
  <<: *commonSettings
  enabled: true
  image:
    repository: ghcr.io/meteroid-oss/metering-api
    tag: tip
  service:
    type: ClusterIP
    ports:
      http: 8081
      grpc: 50062
  config:
    kafka:
      topic: "meteroid-events-raw"
      producerLingerMs: 100
      producerQueueMib: 100
      messageTimeoutMs: 30000
      compressionCodec: "gzip"
  grpcStartupProbe:
    initialDelaySeconds: 5
    periodSeconds: 5
    failureThreshold: 10
  grpcLivenessProbe:
    periodSeconds: 20
  grpcReadinessProbe:
    periodSeconds: 10

# Scheduler Configuration
scheduler:
  <<: *commonSettings
  image:
    repository: ghcr.io/meteroid-oss/meteroid-scheduler
    tag: tip
  config:
    enableMultiOrganization: false
    svixServerUrl: ""
    kafka: {}

# Dependencies
postgresql:
  enabled: true
  primary:
    persistence:
      size: 1Gi
  auth:
    username: postgres
    password: "postgres"
    database: meteroid

kafka:
  enabled: true
  listeners:
    client:
      protocol: "PLAINTEXT"
    interbroker:
      protocol: "PLAINTEXT"
    controller:
      protocol: "PLAINTEXT"
  controller:
    replicaCount: 1
    resourcesPresets: "none"
  broker:
    replicaCount: 1
    resourcesPresets: "none"
  zookeeper:
    replicaCount: 1
  provisionning:
    replicationFactor: 1
  resources:
    limits:
      cpu: 400m
      memory: 1Gi
    requests:
      cpu: 250m
      memory: 256Mi
  extraConfig: |
    offsets.topic.replication.factor=1
    transaction.state.log.replication.factor=1
    auto.create.topics.enable=true

clickhouse:
  enabled: true
  image:
    repository: clickhouse/clickhouse-server
    tag: 24.2.2
    pullPolicy: IfNotPresent
  auth:
    username: "default"
  database: meteroid
  service:
    type: ClusterIP
  persistence:
    accessMode: ReadWriteOnce
    size: 10Gi
